// Generated by dts-bundle-generator v6.12.0

import * as i0 from '@angular/core'
import { Type, ViewContainerRef } from '@angular/core'
import { AbstractControl, AsyncValidatorFn, FormArray, FormGroup, FormGroupDirective, ValidatorFn } from '@angular/forms'
import { Observable, Subject } from 'rxjs'

declare const THEME_COLORS: {
	primary: {
		50: string;
		100: string;
		200: string;
		300: string;
		400: string;
		500: string;
		600: string;
		700: string;
		800: string;
		900: string;
		A100: string;
		A200: string;
		A400: string;
		A700: string;
		contrast: {
			50: string;
			100: string;
			200: string;
			300: string;
			400: string;
			500: string;
			600: string;
			700: string;
			800: string;
			900: string;
			A100: string;
			A200: string;
			A400: string;
			A700: string;
		};
	};
	accent: {
		50: string;
		100: string;
		200: string;
		300: string;
		400: string;
		500: string;
		600: string;
		700: string;
		800: string;
		900: string;
		A100: string;
		A200: string;
		A400: string;
		A700: string;
		contrast: {
			50: string;
			100: string;
			200: string;
			300: string;
			400: string;
			500: string;
			600: string;
			700: string;
			800: string;
			900: string;
			A100: string;
			A200: string;
			A400: string;
			A700: string;
		};
	};
	warn: {
		50: string;
		100: string;
		200: string;
		300: string;
		400: string;
		500: string;
		600: string;
		700: string;
		800: string;
		900: string;
		A100: string;
		A200: string;
		A400: string;
		A700: string;
		contrast: {
			50: string;
			100: string;
			200: string;
			300: string;
			400: string;
			500: string;
			600: string;
			700: string;
			800: string;
			900: string;
			A100: string;
			A200: string;
			A400: string;
			A700: string;
		};
	};
	background: {
		50: string;
		100: string;
		200: string;
		300: string;
		400: string;
		500: string;
		600: string;
		700: string;
		800: string;
		900: string;
		A100: string;
		A200: string;
		A400: string;
		A700: string;
		contrast: {
			50: string;
			100: string;
			200: string;
			300: string;
			400: string;
			500: string;
			600: string;
			700: string;
			800: string;
			900: string;
			A100: string;
			A200: string;
			A400: string;
			A700: string;
		};
	};
}
export enum BoardFabricObjectType {
	NullObject = "nullobject",
	Image = "image",
	View = "view",
	Path = "path",
	ScreenShare = "screenshare",
	LiveVideo = "livevideo",
	StickyNote = "stickynote",
	StickyPad = "stickypad",
	Widget = "widget",
	Text = "text",
	Document = "document",
	Shape = "shape",
	Container = "container",
	Slide = "slide",
	QRCode = "qrcode",
	Comment = "comment",
	Sticker = "sticker",
	Video = "video",
	VideoStream = "videostream",
	MapMarker = "mapmarker"
}
export enum FileSystemNodeClassifier {
	None = "None",
	Image = "Image",
	Audio = "Audio",
	Video = "Video",
	Document = "Document",
	External = "External",
	Model = "Model",
	RichText = "RichText",
	Blob = "Blob",
	SlideTemplate = "SlideTemplate",
	Embed = "Embed",
	AdaptiveCardTemplate = "AdaptiveCardTemplate",
	VideoStream = "VideoStream",
	ExternalWidget = "ExternalWidget",
	MeetingRecording = "MeetingRecording",
	View = "View",
	Log = "Log",
	SerializedBoard = "SerializedBoard",
	RoomImage = "RoomImage",
	RoomVideo = "RoomVideo",
	ThemeImage = "ThemeImage",
	UserImage = "UserImage",
	BoardImage = "BoardImage",
	BoardViewerData = "BoardViewerData",
	BoardLoadDiagnosticData = "BoardLoadDiagnosticData",
	Font = "Font"
}
export enum FileSystemNodeType {
	File = "File",
	Folder = "Folder"
}
export enum FileSystemContainerPermission {
	Viewer = "Viewer",
	Editor = "Editor",
	Owner = "Owner",
	NoAccess = "NoAccess"
}
export enum FileContainerScope {
	Global = "Global",
	Partner = "Partner",
	Organization = "Organization",
	User = "User",
	Board = "Board",
	ThirdParty = "ThirdParty",
	UserRecent = "UserRecent",
	UserFavorite = "UserFavorite",
	UserFrequent = "UserFrequent"
}
export enum FileContainerType {
	Haptic = "Haptic",
	MicrosoftOneDrive = "MicrosoftOneDrive",
	GoogleDrive = "GoogleDrive",
	Computed = "Computed"
}
export enum BoardMemberPermission {
	Viewer = "Viewer",
	Contributor = "Contributor",
	Editor = "Editor",
	Owner = "Owner",
	Developer = "Developer"
}
export enum ThirdPartyAuthProvider {
	Haptic = "Haptic",
	Slack = "Slack",
	Microsoft = "Microsoft",
	Google = "Google",
	Zoom = "Zoom",
	Lifesize = "Lifesize",
	Webex = "Webex",
	BlueJeans = "BlueJeans",
	Chime = "Chime",
	HappyFox = "HappyFox"
}
export enum ThirdPartyConnectMode {
	Default = "Default",
	HapticConnect = "HapticConnect",
	HapticLogin = "HapticLogin",
	HapticSignUp = "HapticSignUp",
	External = "External"
}
export enum ThirdPartyConnectionScope {
	Default = "Default",
	Profile = "Profile",
	ZoomApp = "ZoomApp",
	SlackApp = "SlackApp",
	GoogleDrive = "GoogleDrive",
	MicrosoftOneDrive = "MicrosoftOneDrive",
	MicrosoftMeeting = "MicrosoftMeeting",
	GoogleMeeting = "GoogleMeeting",
	ZoomMeeting = "ZoomMeeting",
	MicrosoftCalendar = "MicrosoftCalendar",
	GoogleCalendar = "GoogleCalendar",
	MicrosoftTeams = "MicrosoftTeams"
}
export enum ThirdPartyConnectionType {
	Default = "Default",
	Auth = "Auth",
	AuthAndDataAccess = "AuthAndDataAccess",
	App = "App"
}
export enum WidgetType {
	Appstream = "appstream",
	Gif = "gif",
	Audio = "audio",
	Embed = "embed",
	Html = "html",
	Link = "link",
	Model = "model",
	Vnc = "vnc",
	Spreadsheet = "spreadsheet",
	Clock = "clock",
	AdaptiveCard = "adaptivecard",
	BoardCalendar = "boardcalendar",
	External = "external",
	CollaborativeNotepad = "collaborativenotepad",
	Livevideo = "livevideo",
	Richtext = "richtext",
	Screenshare = "screenshare",
	Video = "video",
	RemoteApp = "remoteapp"
}
export declare class PartialUserProfile {
	name: string
	imageUrl?: string
	aliasName?: string
	color?: string
}
export enum UserType {
	User = "User",
	MeetingRoom = "MeetingRoom",
	Guest = "Guest",
	Temporary = "Temporary",
	System = "System"
}
export enum BoardHubUserType {
	Undetermined = "Undetermined",
	User = "User",
	Guest = "Guest"
}
export enum UserPurpose {
	Default = "Default",
	Recording = "Recording",
	PdfExport = "PdfExport"
}
export enum SpotlightMode {
	Spotlight = "Spotlight",
	Flashlight = "Flashlight",
	LaserPointer = "LaserPointer"
}
/**
 * This is an alias type for strings containing a url
 *
 * @TJS-format uri-reference
 */
export declare type UrlString = string;
/**
 * This is an alias type for string containing a semantic version number
 * See [[https://semver.npmjs.com/]]
 *
 * @TJS-format semver
 */
export declare type Semver = string;
/**
 * This is an alias type for string containing
 * a semantic version range match expresssion
 * See [[https://semver.npmjs.com/]]
 *
 * @TJS-format semver-range
 */
export declare type SemverRange = string;
/**
 * Alleo Widget API version
 */
export enum WidgetApiVersion {
	/**
	 * V0 is obsolete and kept for legacy reasons
	 */
	V0 = 0,
	/**
	 * Current Alleo Widget API version
	 */
	V1 = 1
}
export interface IWidgetEntrypoint {
	/**
	 * [[SemverRange | Range]] where this entrypoint is valid
	 */
	range: SemverRange;
	/**
	 * Url to html entrypoint
	 */
	entrypoint: UrlString;
	/**
	 * Alleo API Version to be used
	 *
	 * @default 1
	 */
	apiVersion: WidgetApiVersion;
	/**
	 * Entrypoint priority, if there are any overlaps in the [[range | ranges]]
	 * you define, the one with the highest priority will be used. If there are
	 * overlaps but there is no priority defined the first match will be selected
	 * using the [[IWidgetManifest.entrypoints | entrypoints]] list order.
	 */
	priority?: number;
}
export interface IWidgetManifest {
	/**
	 * Widget name
	 */
	name: string;
	/**
	 * Widget description
	 */
	description: string;
	/**
	 * List of tags describing this widget
	 */
	tags?: string[];
	/**
	 * Url to widget icon
	 */
	iconUrl: UrlString;
	/**
	 * List of thumbnail urls
	 */
	thumbnails?: UrlString[];
	/**
	 * Widget author
	 */
	author: string;
	/**
	 * Widget author address (email, website or other)
	 */
	authorUrl: UrlString;
	/**
	 * Widget license
	 */
	license?: string;
	/**
	 * Current widget [[Semver | version]] (to be used when creating new widgets).
	 * Note that at least one [[entrypoints | entrypoint]] must match this version.
	 */
	version: Semver;
	/**
	 * Starting widget width
	 *
	 * @TJS-type integer
	 */
	width: number;
	/**
	 * Starting widget height
	 *
	 * @TJS-type integer
	 */
	height: number;
	/**
	 * List of widget entrypoints
	 *
	 * @minItems 1
	 */
	entrypoints: IWidgetEntrypoint[];
	/**
	 * Widget specific configuration values, will be passed to widget
	 * instances as `haptic.manifestConfig`
	 *
	 * @additionalProperties true
	 */
	config?: {};
}
export declare class UserDto {
	aliasName?: string
	analyticsSessionId?: string
	name: string
	color: string
	id: string
	connectionId: string
	cursorPos: CursorPosUpdateDto
	lastActivityAt: Date
	createdAt: Date
	canvasProperties: CanvasPropertiesUpdateDto
	boardId: string
	permission?: BoardMemberPermission
	minPermission?: BoardMemberPermission
	imageUrl: string
	type: BoardHubUserType
	userType: UserType
	boardViewMode?: string
	boardViewModeId?: string
	purpose?: UserPurpose
}
export declare class Coord2D {
	x: number
	y: number
}
export declare class CursorPosUpdateDto {
	coords: Coord2D
	coordsAbsolute: Coord2D
	spotlightEnabled?: boolean
	spotlightSize?: number
	spotlightMode?: SpotlightMode
}
export declare class CanvasPropertiesUpdateDto {
	connectionId?: string
	pan: Coord2D
	zoom: number
	viewport: Coord2D[]
	areaId?: string
}
export enum ShapeType {
	Square = "square",
	Rectangle = "rectangle",
	RoundedRectangle = "roundedrectangle",
	Circle = "circle",
	Ellipse = "ellipse",
	Triangle = "triangle",
	Star = "star",
	Diamond = "diamond",
	Ngon = "ngon"
}
export enum FileProcessingType {
	None = "None",
	Thumbnail = "Thumbnail",
	Convert = "Convert",
	ViewsPdfExport = "ViewsPdfExport"
}
export declare class FileChangedNotificationData {
	fileId: string
}
export declare class FileProcessingNotificationData {
	fileId: string
	error: string
	processingType: FileProcessingType
}
export declare class ObjectLinkedNotificationData {
	source: LinkedObjectData
	added?: LinkedObjectData[]
	removed?: LinkedObjectData[]
}
export declare class LinkedObjectData {
	id: string
	shortId: string
}
export enum BoardObjectExtraDataType {
	None = "None",
	Vote = "Vote",
	RichTextContent = "RichTextContent",
	LookupTag = "LookupTag",
	VisibilityToggleState = "VisibilityToggleState",
	AdaptiveCardFormData = "AdaptiveCardFormData",
	Reactions = "Reactions",
	Chat = "Chat",
	Reserved1 = "Reserved1",
	Reserved2 = "Reserved2",
	Reserved3 = "Reserved3",
	Reserved4 = "Reserved4",
	Reserved5 = "Reserved5",
	SyncMessage = "SyncMessage"
}
export declare class BoardObjectVoteExtraData {
	userName: string
	userId: string
	date: Date
}
export declare class BoardObjectVisibilityToggleStateExtraData {
	userName: string
	userId: string
	state: boolean
	date: Date
}
export declare class BoardObjectReactionsExtraData {
	reactions: string[]
}
declare class ObjectExtraDataBaseDto {
	referenceId?: string
	boardObjectId: string
	dataType: BoardObjectExtraDataType
}
export declare type BoardObjectExtraDataPayload = BoardObjectVoteExtraData | BoardObjectVisibilityToggleStateExtraData | BoardObjectReactionsExtraData;
export declare class ObjectExtraDataDto {
	data: BoardObjectExtraDataPayload
	createdAt: Date
	referenceId: string
}
export enum ObjectExtraDataQueryType {
	Default = "Default",
	HasAny = "HasAny"
}
export enum ObjectExtraDataDeletionType {
	Default = "Default",
	ByObjectAndType = "ByObjectAndType",
	ByObject = "ByObject"
}
export declare class ObjectExtraDataDeletedDto extends ObjectExtraDataBaseDto {
	deletionType: ObjectExtraDataDeletionType
}
export declare class ObjectExtraDataCreatedDto extends ObjectExtraDataBaseDto {
	data: BoardObjectExtraDataPayload
}
export declare class ObjectExtraDataModifiedDto extends ObjectExtraDataBaseDto {
	data: BoardObjectExtraDataPayload
	delta: boolean
}
export declare class BoardObjectExtraDataQueryResultDto {
	count: number
	hasAny: boolean
	results: ObjectExtraDataDto[]
}
export declare class ObjectSyncMessageDto {
	data: any
	sourceShortId: string
	sourceId: string
	targetIds: string[]
}
export declare class WidgetMessageDto {
	connectionId?: string
	widgetId: string
	payload: Record<string, unknown>
}
export enum ColorPalette {
	Drawing = "Drawing",
	StickyNote = "StickyNote",
	Text = "Text",
	MapMarker = "MapMarker",
	Object = "Object"
}
export declare class MinimalUserDto {
	id: string
	name: string
	imageUrl?: string
	organization?: OrganizationDto
}
export declare class OrganizationDto {
	id: string
	name: string
	expirationDate?: Date
}
export declare class StorageNodeCreatedResponseDto {
	node: FileSystemNodeDto
}
export declare class FileSystemContainerDto {
	id: string
	scopeId: string
	scope: FileContainerScope
	permission: FileSystemContainerPermission
	type: FileContainerType
	thirdPartyConnection: ThirdPartyConnectionDto
}
export declare class FilePartDto {
	url: string
}
export declare class FileSystemNodeDto {
	id: string
	revisionId?: string
	name: string
	description: string
	nodeType: FileSystemNodeType
	path: string
	createdBy: MinimalUserDto
	lastModifiedBy: MinimalUserDto
	container: FileSystemContainerDto
	createdAt: Date
	modifiedAt?: Date
	meta: FileMeta
	parts: Record<string, FilePartDto>
	classifier: FileSystemNodeClassifier
	size: number
	tags: string[]
	sourceLocation: string
	sourceContainer: FileSystemContainerDto
	webUrl: string
	isFavorite: boolean
}
export declare class FileMeta {
	size: number
	extension: string
	mimeType: string
}
export declare class ThirdPartyConnectionDto {
	accessToken: string
	accessTokenExpiresAt?: Date
	isAccessTokenExpired: boolean
	id: string
	isConnected: boolean
	displayName: string
	provider: ThirdPartyAuthProvider
	providerKey: string
	scopes: string
	scope: ThirdPartyConnectionScope
	type: ThirdPartyConnectionType
	connectMode: ThirdPartyConnectMode
	externalUserEmail: string
}
export enum ApiResponseErrorCode {
	ModelStateInvalid = "ModelStateInvalid",
	UserNotFound = "UserNotFound",
	UserAccountDisabled = "UserAccountDisabled",
	ThirdPartyConnectionProviderKeyNotFound = "ThirdPartyConnectionProviderKeyNotFound",
	StorageNodeSourceDeleted = "StorageNodeSourceDeleted",
	BoardAccessDenied = "BoardAccessDenied",
	EntityNotFound = "EntityNotFound",
	BearerTokenUserNotFound = "BearerTokenUserNotFound",
	StorageNodeNotFound = "StorageNodeNotFound",
	EntityLimit = "EntityLimit"
}
export interface MemoizeDebouncedFunction<F extends (...args: any[]) => any> {
	(...args: Parameters<F>): void;
	flush: (...args: Parameters<F>) => void;
}
declare function memoizeDebounce<F extends (...args: any[]) => any>(func: F, wait?: number, options?: _.DebounceSettings, resolver?: (...args: Parameters<F>) => unknown): MemoizeDebouncedFunction<F>;
export interface MemoizeThrottledFunction<F extends (...args: any[]) => any> {
	(...args: Parameters<F>): void;
	flush: (...args: Parameters<F>) => void;
}
declare function memoizeThrottle<F extends (...args: any[]) => any>(func: F, wait?: number, options?: _.ThrottleSettings, resolver?: (...args: Parameters<F>) => unknown): MemoizeThrottledFunction<F>;
export declare type DeepPartial<T> = T extends Record<string | number, unknown> ? {
	[P in keyof T]?: DeepPartial<T[P]>;
} : T;
export declare class ExternallyResolvedPromise<T> implements Promise<T> {
	private resolver
	private rejector
	private resolved
	get isResolved(): boolean;
	private rejected
	get isRejected(): boolean;
	private promise
	constructor();
	resolve(res: T): void;
	reject(reason: any): void;
	then<TResult1 = T, TResult2 = never>(onfulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
	catch<TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>): Promise<T | TResult>;
	finally(onfinally?: () => void): Promise<T>;
	[Symbol.toStringTag]: string
}
export declare class Utils {
	static throttle: <T extends (...args: any) => any>(func: T, wait?: number, options?: import("lodash").ThrottleSettings) => import("lodash").DebouncedFunc<T>
	static debounce: {
		<T extends (...args: any) => any>(func: T, wait: number, options: import("lodash").DebounceSettingsLeading): import("lodash").DebouncedFuncLeading<T>;
		<T_1 extends (...args: any) => any>(func: T_1, wait?: number, options?: import("lodash").DebounceSettings): import("lodash").DebouncedFunc<T_1>;
	}
	static memoizeDebounce: typeof memoizeDebounce
	static memoizeThrottle: typeof memoizeThrottle
	static uniq: <T>(array: import("lodash").List<T>) => T[]
	static get: {
		<TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [
			TKey
		]): TObject[TKey];
		<TObject_1 extends object, TKey_1 extends keyof TObject_1>(object: TObject_1, path: TKey_1 | [
			TKey_1
		]): TObject_1[TKey_1];
		<TObject_2 extends object, TKey_2 extends keyof TObject_2, TDefault>(object: TObject_2, path: TKey_2 | [
			TKey_2
		], defaultValue: TDefault): TDefault | Exclude<TObject_2[TKey_2], undefined>;
		<TObject_3 extends object, TKey1 extends keyof TObject_3, TKey2 extends keyof TObject_3[TKey1]>(object: TObject_3, path: [
			TKey1,
			TKey2
		]): TObject_3[TKey1][TKey2];
		<TObject_4 extends object, TKey1_1 extends keyof TObject_4, TKey2_1 extends keyof TObject_4[TKey1_1]>(object: TObject_4, path: [
			TKey1_1,
			TKey2_1
		]): TObject_4[TKey1_1][TKey2_1];
		<TObject_5 extends object, TKey1_2 extends keyof TObject_5, TKey2_2 extends keyof TObject_5[TKey1_2], TDefault_1>(object: TObject_5, path: [
			TKey1_2,
			TKey2_2
		], defaultValue: TDefault_1): TDefault_1 | Exclude<TObject_5[TKey1_2][TKey2_2], undefined>;
		<TObject_6 extends object, TKey1_3 extends keyof TObject_6, TKey2_3 extends keyof TObject_6[TKey1_3], TKey3 extends keyof TObject_6[TKey1_3][TKey2_3]>(object: TObject_6, path: [
			TKey1_3,
			TKey2_3,
			TKey3
		]): TObject_6[TKey1_3][TKey2_3][TKey3];
		<TObject_7 extends object, TKey1_4 extends keyof TObject_7, TKey2_4 extends keyof TObject_7[TKey1_4], TKey3_1 extends keyof TObject_7[TKey1_4][TKey2_4]>(object: TObject_7, path: [
			TKey1_4,
			TKey2_4,
			TKey3_1
		]): TObject_7[TKey1_4][TKey2_4][TKey3_1];
		<TObject_8 extends object, TKey1_5 extends keyof TObject_8, TKey2_5 extends keyof TObject_8[TKey1_5], TKey3_2 extends keyof TObject_8[TKey1_5][TKey2_5], TDefault_2>(object: TObject_8, path: [
			TKey1_5,
			TKey2_5,
			TKey3_2
		], defaultValue: TDefault_2): TDefault_2 | Exclude<TObject_8[TKey1_5][TKey2_5][TKey3_2], undefined>;
		<TObject_9 extends object, TKey1_6 extends keyof TObject_9, TKey2_6 extends keyof TObject_9[TKey1_6], TKey3_3 extends keyof TObject_9[TKey1_6][TKey2_6], TKey4 extends keyof TObject_9[TKey1_6][TKey2_6][TKey3_3]>(object: TObject_9, path: [
			TKey1_6,
			TKey2_6,
			TKey3_3,
			TKey4
		]): TObject_9[TKey1_6][TKey2_6][TKey3_3][TKey4];
		<TObject_10 extends object, TKey1_7 extends keyof TObject_10, TKey2_7 extends keyof TObject_10[TKey1_7], TKey3_4 extends keyof TObject_10[TKey1_7][TKey2_7], TKey4_1 extends keyof TObject_10[TKey1_7][TKey2_7][TKey3_4]>(object: TObject_10, path: [
			TKey1_7,
			TKey2_7,
			TKey3_4,
			TKey4_1
		]): TObject_10[TKey1_7][TKey2_7][TKey3_4][TKey4_1];
		<TObject_11 extends object, TKey1_8 extends keyof TObject_11, TKey2_8 extends keyof TObject_11[TKey1_8], TKey3_5 extends keyof TObject_11[TKey1_8][TKey2_8], TKey4_2 extends keyof TObject_11[TKey1_8][TKey2_8][TKey3_5], TDefault_3>(object: TObject_11, path: [
			TKey1_8,
			TKey2_8,
			TKey3_5,
			TKey4_2
		], defaultValue: TDefault_3): TDefault_3 | Exclude<TObject_11[TKey1_8][TKey2_8][TKey3_5][TKey4_2], undefined>;
		<T>(object: import("lodash").NumericDictionary<T>, path: number): T;
		<T_1>(object: import("lodash").NumericDictionary<T_1>, path: number): T_1;
		<T_2, TDefault_4>(object: import("lodash").NumericDictionary<T_2>, path: number, defaultValue: TDefault_4): T_2 | TDefault_4;
		<TDefault_5>(object: null, path: import("lodash").PropertyPath, defaultValue: TDefault_5): TDefault_5;
		(object: null, path: import("lodash").PropertyPath): undefined;
		(object: any, path: import("lodash").PropertyPath, defaultValue?: any): any;
	};
	static set: {
		<T extends object>(object: T, path: import("lodash").PropertyPath, value: any): T;
		<TResult>(object: object, path: import("lodash").PropertyPath, value: any): TResult;
	};
	static has: <T>(object: T, path: import("lodash").PropertyPath) => boolean
	static merge: {
		<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
		<TObject_1, TSource1, TSource2>(object: TObject_1, source1: TSource1, source2: TSource2): TObject_1 & TSource1 & TSource2;
		<TObject_2, TSource1_1, TSource2_1, TSource3>(object: TObject_2, source1: TSource1_1, source2: TSource2_1, source3: TSource3): TObject_2 & TSource1_1 & TSource2_1 & TSource3;
		<TObject_3, TSource1_2, TSource2_2, TSource3_1, TSource4>(object: TObject_3, source1: TSource1_2, source2: TSource2_2, source3: TSource3_1, source4: TSource4): TObject_3 & TSource1_2 & TSource2_2 & TSource3_1 & TSource4;
		(object: any, ...otherArgs: any[]): any;
	}
	static setInterval: typeof window.setInterval
	static clearInterval: typeof window.clearInterval
	static setTimeout: typeof window.setTimeout
	static clearTimeout: typeof window.clearTimeout
	static requestAnimationFrame: typeof window.requestAnimationFrame
	static cancelAnimationFrame: typeof window.cancelAnimationFrame
	static Promise: typeof Promise
	static ExternallyResolvedPromise: typeof ExternallyResolvedPromise
	private static guidPattern
	static isGuid(str: string): boolean;
	static newGuid(): string;
	static extractGuid(str: string): string;
	static hasMaybeDevConsoleDocked(): boolean;
	static getScreenResolution(): string;
	static dateToFormattedString(date: Date): string;
	static relativeTimeTo(to: Date): string;
	static localDateTime(): string;
	static getLocale(): string;
	static getDeviceData(): import("ua-parser-js").IResult;
	static isMobile(): boolean;
	static isTablet(): boolean;
	static isIPhone(): boolean;
	static isMacOs(): boolean;
	private static isDevice
	static isTouchSupported(): boolean;
	static isPenEvent(event: PointerEvent | TouchEvent | MouseEvent): boolean;
	static isEraserEvent(event: PointerEvent): boolean;
	static isPenAndNotEraser(event: PointerEvent): boolean;
	static isPenRightClick(event: PointerEvent): boolean;
	static isMouse(event: any): boolean;
	static getDomainFromUrl(url: string): string;
	static isValidDomain(domain: string): boolean;
	static getToplevelDomainFromUrl(url: string): string;
	static isIpAddress(str: string): boolean;
	static isApiErrorCode(err: any, code: ApiResponseErrorCode): boolean;
	static isApiError(err: any): boolean;
	static isUrlAbsolute(url: string): boolean;
	static isJson(str: string): boolean;
	static clone<T>(obj: T): T;
	static deepMap(obj: any, iterator: (v: unknown, key: string, obj: unknown) => unknown, accumulatedKey?: string, context?: any): unknown;
	static deepMapNoArray(obj: any, iterator: (v: unknown, key: string, obj: unknown) => unknown, accumulatedKey?: string, context?: any): unknown;
	static objectToQueryString(a: any, useArrayIndex?: boolean, useArrayBrackets?: boolean): string;
	static getObjectFromQuery(queryStr: string): any;
	static paramsToObject(entries: any): any;
	static uuidv4(): string;
	static randomStr(length: number): string;
	static randomInt(min: any, max: any): any;
	static trim(s: any, c: any): any;
	static capitalize(s: string): string;
	static unCapitalize(s: string): string;
	static lowerCaseEqual(a: string, b: string): boolean;
	static truncate(str: string, n: number): string;
	static getFileExtension(fileName: string): string;
	static getFileName(fileName: string): string;
	static imgCache: Map<string, string>
	static createWorker(func: () => any): Worker;
	static loadImageViaWorker(url: string): Promise<unknown>;
	static loadImage(fileUrl: string): Promise<HTMLImageElement>;
	static loadImageIntoBlob(url: string): Promise<string>;
	static getImageSize(url: string, crossOrigin?: null | "use-credentials" | "anonymous"): Promise<{
		width: number;
		height: number;
	}>;
	static calculateAspectRatioFit(srcWidth: any, srcHeight: any, maxWidth: any, maxHeight: any): {
		width: number;
		height: number;
	};
	static calculateAspectRatio(srcWidth: any, srcHeight: any, maxWidth: any, maxHeight: any): number;
	static map(x: number, inMin: number, inMax: number, outMin: number, outMax: number): number;
	static makeDate(date: Date): Date;
	static enterFullscreen(): void;
	static exitFullscreen(): void;
	static isInFullscreen(): boolean;
	static dataURItoBlob(dataURI: string): Blob;
	static blobToFile(blob: Blob, fileName: string): File;
	static dataURItoFile(dataURI: string, fileName: string): File;
	static hashObject(object: any): number;
	static hashString(key: string, seed?: string): number;
	static hashColor(str: string, startColor?: string): string;
	static getElementPosition(el: any): {
		left: any;
		top: any;
	};
	static getPreferredAudioFormat(): "mp3" | "ogg" | "wav";
	static getVideoSizeFromUrl(url: string, ...additionalCacheKeys: any[]): null | Promise<{
		width: number;
		height: number;
	}>;
	static arraysEqual<T>(a: T[], b: T[], comparator?: (a: T, b: T) => number): boolean;
	static selectFile(allowedMimetypes?: string, multiple?: boolean): Promise<File | File[] | false>;
	static replaceInvalidFileNameChars(name: string, separator?: string): string;
	static getMimetype(file: File): Promise<any>;
	static getFileType(mimetype: string, ext?: string): FileSystemNodeClassifier | null;
	static getFileTypeFromExtension(ext: any): FileSystemNodeClassifier | null;
	static doDownloadFile(url: string, filename?: string): Promise<void>;
	private static downloadQueue
	static downloadFile(url: string, filename?: string): Promise<void>;
	static downloadBlob(blob: Blob, filename: string): void;
	static sleep(ms?: any): Promise<unknown>;
	/** This basically is a queueMicrotask in a promise so effectively we can await queueMicrotask */
	static asyncDefer(): Promise<void>;
	static defer(fn: () => void): void;
	static waitWithTimeout<T>(promise: Promise<T>, ms: number, timeoutError?: Error): Promise<T>;
	/** the condition function result is checked for truthiness if a single value is returned
	 *  and for values being non-null in case it returns an array
	 */
	static waitUntil(condition: () => any | Array<any>, checkIntervalMs?: number, timeoutMs?: number): Promise<any>;
	/** the condition function result is checked for truthiness if a single value is returned
	 *  and for values being non-null in case it returns an array
	 */
	static executeWhen(condition: () => any | Array<any>, action: () => Promise<any>, checkIntervalMs?: number, timeoutMs?: number): void;
	static isEdge(): boolean;
	static isSafari(): boolean;
	static isFirefox(): boolean;
	/**
	 * This is a safari workaround to allow starting audio, if we need to start audio in an async callback after
	 * user interaction it won't play unless we have played a sound synchronously inside event for a user interaction
	 */
	static playMuteSound(sinkId?: string): void;
	static getDisplayMedia(constraints: any): Promise<MediaStream>;
	static isUriComponentEncoded(uri: string): boolean;
	static dayOfTheYear(): number;
	static canvasToBlob(canvas: HTMLCanvasElement, mimetype?: string, quality?: number): Promise<Blob>;
	static imageToBlob(img: HTMLImageElement): Promise<Blob>;
	static smoothstep(min: number, max: number, value: number): number;
	static generateCombinations(arr: any[], size: number): Generator<any, void, any>;
	static generatePairs<T = unknown>(arr: T[]): Generator<[
		T,
		T,
		number,
		number
	], void, unknown>;
	static readFileAsText(file: File): Promise<string>;
	static assertUnreachable(param: never): never;
	static getPasteAsString(item: any): Promise<{
		type: string;
		data: string;
	}>;
	static escapeHTML(str: any): string;
	static writeClipboardText(text: string, successNotification?: string): Promise<boolean>;
	static getInitials(str: string): string;
	static stringify: any
	static jsonEqualPickFields(...fields: string[]): (a: unknown, b: unknown) => boolean;
	static jsonEqualOmitFields(...fields: string[]): (a: unknown, b: unknown) => boolean;
	static jsonEqual(a: unknown, b: unknown): boolean;
	static createStyleElementFromJson(cssData: any, prefixClass: string): HTMLStyleElement;
	static isTextInputFocused(): boolean;
	static getFirstInSet<T>(s?: Set<T>): T;
	private static audioCtx
	static getAudioContext(): AudioContext;
	static toMaxPrecision(n: number, precision: number): string;
	static wildcardToRegexp(str: string): RegExp;
	static escapeRegex(str: any): any;
	static isDocumentVisible(): boolean;
	static setPropertyIfChanged(domEl: HTMLElement, property: string, value: string): void;
	static createOffscreenCanvas(width: number, height: number): any;
	static retry<T extends (...arg0: any[]) => any>(action: T, maxRetries?: number, retryAction?: (err: any) => void, retryCount?: number): Promise<Awaited<ReturnType<T>>>;
	static toEnumIgnoreCase<T>(target: T, key: string): T[keyof T];
}
declare abstract class FieldType<F extends FormlyFieldConfig = FormlyFieldConfig> {
	field: F
	defaultOptions?: Partial<F>
	get model(): any;
	get form(): FormGroup | import("@angular/forms").FormArray;
	get options(): FormlyFormOptions;
	get key(): string | number | (string | number)[];
	get formControl(): NonNullable<F["formControl"]>;
	get props(): NonNullable<F["props"]>;
	/** @deprecated Use `props` instead. */
	get to(): NonNullable<F["props"]>;
	get showError(): boolean;
	get id(): string;
	get formState(): any;
	static ɵfac: i0.ɵɵFactoryDeclaration<FieldType<any>, never>
	static ɵdir: i0.ɵɵDirectiveDeclaration<FieldType<any>, never, never, {
		"field": "field";
	}, {}, never>
}
declare abstract class FieldWrapper<F extends FormlyFieldConfig = FormlyFieldConfig> extends FieldType<F> {
	fieldComponent: ViewContainerRef
	set _staticContent(content: ViewContainerRef);
	static ɵfac: i0.ɵɵFactoryDeclaration<FieldWrapper<any>, never>
	static ɵdir: i0.ɵɵDirectiveDeclaration<FieldWrapper<any>, never, never, {}, {}, never>
}
export interface FormlyFieldConfig<Props = FormlyFieldProps & {
	[additionalProperties: string]: any;
}> {
	/**
	 * The key that relates to the model. This will link the field value to the model
	 */
	key?: string | number | (string | number)[];
	/**
	 * This should be a formly-field type added either by you or a plugin. More information over at Creating Formly Fields.
	 */
	type?: string | Type<FieldType>;
	/**
	 * Use `defaultValue` to initialize it the model. If this is provided and the value of the model at compile-time is undefined, then the value of the model will be assigned to `defaultValue`.
	 */
	defaultValue?: any;
	/**
	 * This allows you to specify the `id` of your field. Note, the `id` is generated if not set.
	 */
	id?: string;
	/**
	 * If you wish, you can specify a specific `name` for your field. This is useful if you're posting the form to a server using techniques of yester-year.
	 */
	name?: string;
	/**
	 * This is reserved for the templates. Any template-specific options go in here. Look at your specific template implementation to know the options required for this.
	 */
	props?: Props;
	/** @deprecated Use `props` instead. */
	templateOptions?: FormlyTemplateOptions;
	/**
	 * An object with a few useful properties
	 * - `validation.messages`: A map of message names that will be displayed when the field has errors.
	 * - `validation.show`: A boolean you as the developer can set to force displaying errors whatever the state of field. This is useful when you're trying to call the user's attention to some fields for some reason.
	 */
	validation?: {
		messages?: {
			[messageProperties: string]: ValidationMessageOption["message"];
		} & {
			/** @deprecated use `minLength` */
			minlength?: ValidationMessageOption["message"];
			/** @deprecated use `maxLength` */
			maxlength?: ValidationMessageOption["message"];
		};
		show?: boolean;
		[additionalProperties: string]: any;
	};
	/**
	 * Used to set validation rules for a particular field.
	 * Should be an object of key - value pairs. The value can either be an expression to evaluate or a function to run.
	 * Each should return a boolean value, returning true when the field is valid. See Validation for more information.
	 */
	validators?: FormlyValidation<ValidatorFn, boolean>;
	/**
	 * Use this one for anything that needs to validate asynchronously.
	 * Pretty much exactly the same as the validators api, except it must be a function that returns a promise.
	 */
	asyncValidators?: FormlyValidation<AsyncValidatorFn, Promise<boolean> | Observable<boolean>>;
	/**
	 * Can be set instead of `type` to render custom html content.
	 */
	template?: string;
	/**
	 *  It is expected to be the name of the wrappers.
	 *  The formly field template will be wrapped by the first wrapper, then the second, then the third, etc.
	 *  You can also specify these as part of a type (which is the recommended approach).
	 */
	wrappers?: (string | Type<FieldWrapper>)[];
	/**
	 * Whether to hide the field. Defaults to false. If you wish this to be conditional use `expressions: { hide: ... }`
	 */
	hide?: boolean;
	/**
	 * Whether to reset the value on hide or not. Defaults to `true`.
	 */
	resetOnHide?: boolean;
	/**
	 * Conditionally hiding Field based on values from other Fields
	 * @deprecated use `expressions: { hide: ... }`
	 */
	hideExpression?: boolean | string | ((model: any, formState: any, field?: FormlyFieldConfig) => boolean);
	/**
	 * An object where the key is a property to be set on the main field config and the value is an expression used to assign that property.
	 * @deprecated use `expressions`
	 */
	expressionProperties?: {
		[property: string]: string | ((model: any, formState: any, field?: FormlyFieldConfig) => any) | Observable<any>;
	};
	/**
	 * An object where the key is a property to be set on the main field config and the value is an expression used to assign that property.
	 */
	expressions?: {
		[property: string]: string | ((field: FormlyFieldConfig) => any) | Observable<any>;
	};
	/**
	 * You can specify your own class that will be applied to the `formly-field` component.
	 */
	className?: string;
	/**
	 * Specify your own class that will be applied to the `formly-group` component.
	 */
	fieldGroupClassName?: string;
	/**
	 * A field group is a way to group fields together, making advanced layout very simple.
	 * It can also be used to group fields that are associated with the same model (useful if it's different than the model for the rest of the fields).
	 */
	fieldGroup?: FormlyFieldConfig[];
	fieldArray?: FormlyFieldConfig | ((field: FormlyFieldConfig) => FormlyFieldConfig);
	/**
	 * Whether to focus or blur the element field. Defaults to false. If you wish this to be conditional use `expressions`
	 */
	focus?: boolean;
	/**
	 * An object with a few useful properties to control the model changes
	 * - `debounce`: integer value which contains the debounce model update value in milliseconds. A value of 0 triggers an immediate update.
	 * - `updateOn`: string event value that instructs when the control should be updated
	 */
	modelOptions?: {
		debounce?: {
			default: number;
		};
		updateOn?: "change" | "blur" | "submit";
	};
	hooks?: FormlyHookConfig;
	/**
	 * Array of functions to execute, as a pipeline, whenever the model updates, usually via user input.
	 */
	parsers?: ((value: any) => any)[];
	/**
	 * Returns child field by key name
	 */
	get?: (key: FormlyFieldConfig["key"]) => FormlyFieldConfig;
	/**
	 * The model that stores all the data, where the model[key] is the value of the field
	 */
	readonly model?: any;
	/**
	 * The parent field.
	 */
	readonly parent?: FormlyFieldConfig;
	/**
	 * The form options.
	 */
	readonly options?: FormlyFormOptions;
	/**
	 * The parent form.
	 */
	readonly form?: FormGroup | FormArray;
	/**
	 * This is the [FormControl](https://angular.io/api/forms/FormControl) for the field.
	 * It provides you more control like running validators, calculating status, and resetting state.
	 */
	readonly formControl?: AbstractControl;
	/** @deprecated */
	optionsTypes?: string[];
}
export declare type FormlyAttributeEvent = (field: FormlyFieldConfig, event?: any) => void;
/**  @deprecated */
export interface FormlyTemplateOptions extends FormlyFieldProps {
	[additionalProperties: string]: any;
}
export interface FormlyFieldProps {
	type?: string;
	label?: string;
	placeholder?: string;
	disabled?: boolean;
	options?: any[] | Observable<any[]>;
	rows?: number;
	cols?: number;
	description?: string;
	hidden?: boolean;
	max?: number;
	min?: number;
	minLength?: number;
	/** @deprecated use `minLength` */
	minlength?: number;
	maxLength?: number;
	/** @deprecated use `maxLength` */
	maxlength?: number;
	pattern?: string | RegExp;
	required?: boolean;
	tabindex?: number;
	readonly?: boolean;
	attributes?: {
		[key: string]: string | number;
	};
	step?: number;
	focus?: FormlyAttributeEvent;
	blur?: FormlyAttributeEvent;
	keyup?: FormlyAttributeEvent;
	keydown?: FormlyAttributeEvent;
	click?: FormlyAttributeEvent;
	change?: FormlyAttributeEvent;
	keypress?: FormlyAttributeEvent;
}
export declare type FormlyHookFn = (field: FormlyFieldConfig) => void;
export interface FormlyHookConfig {
	onInit?: FormlyHookFn;
	onChanges?: FormlyHookFn;
	afterContentInit?: FormlyHookFn;
	afterViewInit?: FormlyHookFn;
	onDestroy?: FormlyHookFn;
}
export interface FormlyFormOptions {
	updateInitialValue?: (model?: any) => void;
	resetModel?: (model?: any) => void;
	formState?: any;
	fieldChanges?: Subject<FormlyValueChangeEvent>;
	showError?: (field: FieldType) => boolean;
	build?: (field?: FormlyFieldConfig) => FormlyFieldConfig;
	checkExpressions?: (field: FormlyFieldConfig) => void;
	detectChanges?: (field: FormlyFieldConfig) => void;
	parentForm?: FormGroupDirective | null;
}
export interface FormlyValueChangeEvent {
	field: FormlyFieldConfig;
	type: string;
	value: any;
	[meta: string]: any;
}
export interface FormlyValidation<T, R> {
	validation?: (string | T)[] | any;
	[key: string]: FormlyValidatorFn<R> | FormlyValidatorExpressionFn<R> | any;
}
export declare type FormlyValidatorFn<T> = (control: AbstractControl, field: FormlyFieldConfig) => T;
export interface FormlyValidatorExpressionFn<T> {
	expression: FormlyValidatorFn<T>;
	message: string | ((error: any, field: FormlyFieldConfig) => string);
}
export interface ValidationMessageOption {
	name: string;
	message: string | ((error: any, field: FormlyFieldConfig) => string | Observable<string>);
}
export declare type FormlyDialogModel = Record<string, any>;
export interface FormlyDialogSettings<T extends FormlyDialogModel = FormlyDialogModel> {
	fields: FormlyFieldConfig[];
	model?: Partial<T>;
	title?: string;
	text?: string;
	submitText?: string;
	cancelText?: string;
	showCloseButton?: boolean;
}
export enum BoardMode {
	Cursor = "Cursor",
	Marker = "Marker",
	Eraser = "Eraser",
	DragSelection = "DragSelection",
	Eyedropper = "Eyedropper",
	ObjectChooser = "ObjectChooser",
	Overview = "Overview"
}
export declare type AVAILABLE_MODULES = "turndown" | "plyr" | "rxjs/operators" | "rxjs" | "lodash-es" | "@babylonjs/loaders" | "@babylonjs/core" | "@syncfusion/ej2-schedule" | "@syncfusion/ej2-spreadsheet" | "chroma-js" | "mediasoup-client" | "socket.io-client" | "monaco-editor" | "markdown-it" | "adaptivecards-designer" | "adaptivecards-templating" | "adaptivecards" | "dashjs" | "hls.js" | "pdfmake" | "html2canvas" | "pdfjs-dist" | "@microsoft/teams-js" | "@opentok/client" | "pako" | "yjs" | "y-quill" | "y-webrtc" | "y-generic" | "quill" | "quill-cursors" | "adaptivecards-extensions" | "comlink" | "alleo-tiptap-starter-kit";
export interface IBoardMember {
	/**
	 * User id
	 */
	readonly id: string;
	/**
	 * User name
	 */
	readonly name: string;
	/**
	 * User email
	 */
	readonly email: string;
	/**
	 * User permission
	 */
	readonly permission: BoardMemberPermission;
	/**
	 * Indicates whether the user has accepted an invitation if applicable
	 */
	readonly isPending: boolean;
}
export interface Position {
	x: number;
	y: number;
}
export interface MapPosition {
	lon: number;
	lat: number;
}
export declare type IPosition = Position | MapPosition;
export interface IBoardObject {
	readonly id: string;
	readonly type: BoardFabricObjectType;
	readonly humanTextId: string;
	moveTo(pos: IPosition): any;
	moveViewportToObject(): Promise<boolean>;
	panViewportToObject(zoomFactor?: number): Promise<boolean>;
	setSize(width: number, height: number): any;
	setScale(scaleX: number, scaleY: number): any;
	getAssetIds(): string[];
	getField(fieldName: string): any;
	setField(fieldName: string, value: any, delta: boolean): void;
}
export interface IBoardUser {
	/**
	 * User id
	 */
	readonly id: string;
	/**
	 * User full name
	 */
	readonly name: string;
	/**
	 * User client connection id
	 */
	readonly connectionId: string;
	/**
	 * Last activity date (cursor move etc.)
	 */
	readonly lastActivityAt: Date;
	/**
	 * User avatar if present
	 */
	readonly imageUrl: string;
	/**
	 * User type
	 */
	readonly type: BoardHubUserType;
	/**
	 * Current user profile, the values iside [[profile]] are preferred over [[name]] and [[imageUrl]]
	 * as it is updated on change while the other 2 are not
	 */
	readonly profile: PartialUserProfile;
	/**
	 * [[Observable]] that emits whenever the user's [[profile]] changes
	 * eg. they change their avatar, alias or color
	 */
	readonly profile$: Observable<PartialUserProfile>;
	/**
	 * User permission level
	 */
	readonly permission: BoardMemberPermission;
	/**
	 * [[Observable]] that emits whenever [[permission]] changes
	 */
	readonly permission$: Observable<BoardMemberPermission>;
	/**
	 * Whether the user can modify content on the board, note that for [[BoardMemberPermission.Contributor]]
	 * users this will be true however they can only interact with the board in a limited capability
	 */
	readonly canEdit: boolean;
	/**
	 * [[Observable]] that emits whenever [[canEdit]] changes
	 */
	readonly canEdit$: Observable<boolean>;
}
export enum UiPanel {
	AssetLibrary = "AssetLibrary",
	UserList = "UserList",
	Chat = "Chat",
	Views = "Views"
}
export interface IExtraDataQuery {
	queryType?: ObjectExtraDataQueryType;
	referenceId?: string;
	dataType: BoardObjectExtraDataType;
	skip?: number;
	take?: number;
}
export interface ILogger {
	getCurrentSessionData(): any;
	startSession(sessionName?: string): Promise<void>;
	endSession(): Promise<void>;
	saveSessionData(): void;
	flush(): Promise<void>;
	trace(...args: any[]): void;
	debug(...args: any[]): void;
	debugNoPersist(...args: any[]): void;
	info(...args: any[]): void;
	warn(...args: any[]): void;
	error(...args: any[]): void;
	critical(...args: any[]): void;
	persistLog(level: string, args: any[]): void;
	toStorable(args: any[]): any[];
}
export interface IWidgetBoardAssets {
	/**
	 * Show selection dialog and return selected file id
	 *
	 * @param types list of types to allow
	 */
	selectFileId(types: FileSystemNodeClassifier[]): Promise<string>;
	/**
	 * Show selection dialog for [[FileSystemNodeClassifier.Image]] and load the selected file into a [[HTMLImageElement]]
	 */
	selectAndLoadImage(): Promise<HTMLImageElement>;
	/**
	 * Upload new or update file contents
	 *
	 * @param fileId
	 * @param fileName
	 * @param contents
	 */
	putFileContents(fileId: string, fileName: string, contents: any): Promise<StorageNodeCreatedResponseDto | null>;
	/**
	 * Get appropriate CORS mode for loading file based on url
	 *
	 * @param url
	 */
	getCorsMode(url: string): string;
	/**
	 * Get file entry
	 *
	 * @param fileId
	 */
	getFileNode(fileId: string): Promise<FileSystemNodeDto>;
	/**
	 * Get url for a given file's contents
	 *
	 * @param fileId
	 * @param revisionId can be omitted, defaults to latest revision
	 * @param fileSize can be omitted, defaults to `Original` filesize
	 */
	getFileUrl(fileId: string, revisionId?: string, fileSize?: string): Promise<string>;
	/**
	 * Get file contents as text
	 *
	 * @param fileId
	 * @param revisionId can be omitted, defaults to latest revision
	 * @param fileSize can be omitted, defaults to `Original` filesize
	 */
	getFileContent(fileId: string, revisionId?: string, fileSize?: string): Promise<string | undefined>;
	/**
	 * Get file contents as JSON
	 *
	 * @param fileId
	 * @param revisionId can be omitted, defaults to latest revision
	 * @param fileSize can be omitted, defaults to `Original` filesize
	 */
	getFileContentJson(fileId: string, revisionId?: string, fileSize?: string): Promise<any | undefined>;
	/**
	 * Emits whenever a file is changed
	 */
	fileChanged$: Observable<FileChangedNotificationData>;
	/**
	 * Emits whenever a file's processing is finished, eg extracting thumbnails or converting formats
	 */
	fileProcessingCompleted$: Observable<FileProcessingNotificationData>;
}
export interface IWidgetBoardMeeting {
	/**
	 * Get user that's currently speaking during an Alleo call
	 */
	readonly activeSpeaker: IBoardUser;
	/**
	 * [[Observable]] that emits whenever [[activeSpeaker]] changes
	 */
	readonly activeSpeaker$: Observable<IBoardUser>;
}
export interface IObjectCreateDataBase {
	position?: IPosition;
}
export interface IScreenShareCreateData extends IObjectCreateDataBase {
	requestVideo?: boolean;
}
export interface ILiveVideoCreateData extends IObjectCreateDataBase {
	requestVideo?: boolean;
}
export interface IStickyNoteCreateData extends IObjectCreateDataBase {
	color?: string;
	outlineColor?: string;
	shape?: ShapeType;
	text?: string;
}
export interface ITextCreateData extends IObjectCreateDataBase {
	text?: string;
	fontSize?: number;
	fill?: string;
}
export interface IContainerCreateData extends IObjectCreateDataBase {
	title?: string;
}
export interface IImageCreateData extends IObjectCreateDataBase {
	file?: File | string;
}
export interface ISlideCreateData {
	templateId?: string;
}
export interface ICollaborativeNotepadCreateData extends IObjectCreateDataBase {
	type: WidgetType.CollaborativeNotepad;
	content: string;
}
export declare type IWidgetCreateData = ICollaborativeNotepadCreateData;
export declare type IObjectCreateData = IObjectCreateDataBase | IStickyNoteCreateData | ITextCreateData | IContainerCreateData | IScreenShareCreateData | ILiveVideoCreateData | IImageCreateData | ISlideCreateData | IWidgetCreateData;
export interface IWidgetBoardObjects {
	/**
	 * Create a new object, note that not all objects are supported
	 *
	 * @param type
	 * @param object
	 */
	create(type: BoardFabricObjectType.ScreenShare, object: IScreenShareCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.LiveVideo, object: ILiveVideoCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.StickyNote, object: IStickyNoteCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.Text, object: ITextCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.Container, object: IContainerCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.Image, object: IImageCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.Slide, object: ISlideCreateData): Promise<IBoardObject>;
	create(type: BoardFabricObjectType.Widget, object: IWidgetCreateData): Promise<IBoardObject>;
	/**
	 * Pan to a given object using default animation, by default this will zoom into the object to
	 * until the object fills the viewport or the zoom limit is reached
	 *
	 * @param object
	 * @param zoomFactor used to control the zoom level, defaults to 1 so can be omitted - lower values will zoom out
	 */
	panTo(object: IBoardObject, zoomFactor?: number): Promise<boolean>;
	/**
	 * Move to given object immediately
	 */
	moveTo(object: IBoardObject): Promise<boolean>;
	/**
	 * Get all objects of a given type
	 *
	 * @param type
	 */
	getByType(type: BoardFabricObjectType): IBoardObject[];
	/**
	 * Get all objects on canvas
	 */
	getAll(): IBoardObject[];
}
export interface IWidgetBoardUi {
	/**
	 * Ui theme colors
	 */
	readonly themeColors: DeepPartial<typeof THEME_COLORS>;
	/**
	 * Open specified UI panel
	 *
	 * @param type
	 */
	openPanel(type: UiPanel): void;
	/**
	 * Close specified UI panel
	 *
	 * @param type
	 */
	closePanel(type: UiPanel): void;
	/**
	 * Change board interaction mode
	 *
	 * @param mode
	 */
	changeMode(mode: BoardMode): void;
}
export interface IWidgetBoardApi {
	/**
	 * Board id
	 */
	readonly id: string;
	/**
	 * Board name
	 */
	readonly name: string;
	/**
	 * Board users
	 */
	readonly users: IBoardUser[];
	/**
	 * Board UI API
	 */
	readonly ui: IWidgetBoardUi;
	/**
	 * Board objects API
	 */
	readonly objects: IWidgetBoardObjects;
	/**
	 * Board meeting API
	 */
	readonly meeting: IWidgetBoardMeeting;
	/**
	 * Board files API
	 */
	readonly assets: IWidgetBoardAssets;
	/**
	 * Indicates whether the board is map type
	 */
	readonly isMap: boolean;
	/**
	 * [[Observable]] that emits whenever a user joined the session
	 */
	readonly userJoined$: Observable<UserDto>;
	/**
	 * [[Observable]] that emits whenever a user left the session
	 */
	readonly userLeft$: Observable<UserDto>;
	/**
	 * Whether the board is in presentation mode currently.
	 * Note that this indicates the local state not whether there's a presentation at all.
	 */
	readonly presentationActive: boolean;
	/**
	 * [[Observable]] that emits when [[presentationActive]] changes
	 */
	readonly presentationActive$: Observable<boolean>;
	/**
	 * Indicates whether the user is currently following a leader
	 * (so their viewport updates when the leader moves)
	 */
	readonly followingUser: boolean;
	/**
	 * [[Observable]] that emits when [[followingUser]] changes
	 */
	readonly followingUser$: Observable<boolean>;
	/**
	 * Indicates whether the current user is leading others
	 */
	readonly leadingUsers: boolean;
	/**
	 * [[Observable]] that emits when [[leadingUsers]] changes
	 */
	readonly leadingUsers$: Observable<boolean>;
	/**
	 * Indicates whether the board is in view-only mode
	 */
	readonly viewOnly: boolean;
	/**
	 * [[Observable]] that emits when [[viewOnly]] changes
	 */
	readonly viewOnly$: Observable<boolean>;
	/**
	 * [[Observable]] that emits when the viewport is changed
	 */
	readonly viewportChanged$: Observable<{
		animation?: boolean;
	}>;
	/**
	 * [[Observable]] that emits when the viewport is panned
	 */
	readonly viewportPanned$: Observable<{
		animation?: boolean;
	}>;
	/**
	 * [[Observable]] that emits when the viewport is zoomed
	 */
	readonly viewportZoomed$: Observable<{
		animation?: boolean;
	}>;
	/**
	 * [[Observable]] that emits when board font configuration is changed or initially subscribed
	 */
	readonly fonts$: Observable<{
		fontFamily: string;
		label: string;
	}[]>;
	/**
	 * [[Observable]] Get the board members, including offline users
	 */
	getMembers(): Promise<IBoardMember[]>;
	/**
	 * Move the current viewport to the given position, using default animation
	 *
	 * @param position
	 * @param zoom
	 */
	panTo(position: IPosition, zoom: number): Promise<void>;
	/**
	 * Move the current viewport to the given position immediately
	 *
	 * @param position
	 */
	moveTo(position: IPosition): any;
	/**
	 * Zoom the current viewport to the given zoom level immediately
	 *
	 * @param position
	 */
	zoomTo(zoom: number): any;
}
export interface IWidgetConfiguration {
	/**
	 * Widget version
	 */
	readonly version: string;
	/**
	 * Widget name
	 * */
	readonly name: string;
	/**
	 * Widget html entrypoint
	 */
	readonly entryPoint: string;
	[propName: string]: any;
}
export interface ContextMenuButtonBase {
	label: string;
	id: string;
}
export declare type ContextMenuIcon = {
	set: "fas" | "mat";
	icon: string;
};
export declare type ContextMenuIconOrImage = ContextMenuIcon | {
	url: string;
};
export interface ContextMenuButton extends ContextMenuButtonBase {
	action: () => void;
	type?: "button" | undefined;
	icon: ContextMenuIconOrImage;
}
export interface ContextMenuDropdown extends ContextMenuButtonBase {
	type: "dropdown";
	items: Omit<ContextMenuButton, "type" | "icon">[];
	icon: ContextMenuIconOrImage;
}
export interface ContextMenuSubmenu extends ContextMenuButtonBase {
	type: "submenu";
	items: Omit<ContextMenuButton, "type">[];
	icon: ContextMenuIconOrImage;
}
export interface ContextMenuColor extends ContextMenuButtonBase {
	type: "color";
	palette?: ColorPalette;
	color: string;
	includeTransparent?: boolean;
	action: (color: string) => void;
	icon: ContextMenuIcon;
}
export interface ContextMenuFont extends ContextMenuButtonBase {
	type: "font";
	font: string;
	action: (font: string) => void;
}
export declare type ContextMenuButtonDefinition = ContextMenuButton | ContextMenuSubmenu | ContextMenuDropdown | ContextMenuColor | ContextMenuFont;
export interface ActionTriggerDefinition {
	label: string;
	id: string;
}
export interface Interactibility {
	/**
	 * The default interactibility state for a widget, it is computed as follows from values in [[state]]
	 * ```typescript
	 * return (
	 *    !state.transforming &&
	 *    !state.multiSelected &&
	 *    (
	 *       state.selected ||
	 *       state.viewOnly ||
	 *       (state.followingUser && !state.canEdit) ||
	 *       state.locked ||
	 *       (state.selectableByLongpress)
	 *    )
	 * );
	 * ```
	 */
	interactible: boolean;
	state: {
		transforming: boolean;
		inViewport: boolean;
		locked: boolean;
		multiSelected: boolean;
		selected: boolean;
		canEdit: boolean;
		viewOnly: boolean;
		presentationActive: boolean;
		followingUser: boolean;
		selectableByLongpress: boolean;
	};
}
export interface IWidgetApi {
	/**
	 * Board API
	 */
	readonly board: IWidgetBoardApi;
	/**
	 * Widget initial config, including all widget data fields at instantiation time
	 */
	readonly config: IWidgetConfiguration;
	/**
	 * Configuration from widget manifest if applicable
	 */
	readonly manifestConfig?: Record<string, any>;
	/**
	 * Widget root DOM element, contents need to added under this element.
	 * Adding content outside is *strongly* discouraged
	 * (eg. via dialogs etc), any elements added outside *need* to be
	 * cleaned up on removal by subscribing to [[widgetDestroyed$]]
	 */
	readonly rootNode: HTMLElement;
	/**
	 * User API for the logged-in user
	 */
	readonly currentUser: IBoardUser;
	/**
	 * Server time, useful for synchronizing between clients eg. in timers,
	 * countdown widgets etc.
	 */
	readonly serverTime: number;
	/**
	 * Same as [[serverTime]] but in milliseconds
	 */
	readonly serverTimeMsec: number;
	/**
	 * Load bundled 3rd party js modules
	 *
	 * @param module any of the supported modules
	 */
	requireModule(module: AVAILABLE_MODULES): Promise<any>;
	/**
	 * Same as [[requireModule]] but takes any number of arguments and returns an array
	 * when everything's loaded
	 *
	 * @param modules any of the supported modules
	 */
	requireModules(...modules: AVAILABLE_MODULES[]): Promise<any[]>;
	/**
	 * Widget object id
	 */
	readonly widgetId: string;
	/**
	 * Boolean indicating whether the widget is being added (new widget created)
	 * or just instantiated, note that this will only be true for the client
	 * that actually has created the object
	 */
	readonly creation: boolean;
	/**
	 * Notify the app that widget has finished instantiating, this *needs* to be
	 * called at the end of init
	 */
	widgetReady(): void;
	/**
	 * Destroy the object
	 */
	destroy(): void;
	/**
	 * An [[Observable]] that emits when the widget is being destroyed, either by calling [[destroy]] or externally
	 */
	readonly widgetDestroyed$: Observable<void>;
	/**
	 * Set the widget's dimensions
	 *
	 * @param width number
	 * @param height number
	 */
	setSize(width: number, height: number): void;
	/**
	 * Set the widget's minimum dimensions (for resieable widgets, see [[enableResizing]])
	 *
	 * @param width number
	 * @param height number
	 */
	setMinSize(width: number, height: number): void;
	/**
	 * Get the widget's size and scale
	 */
	getSize(): {
		scaleX: number;
		scaleY: number;
		width: number;
		height: number;
	};
	/**
	 * Set the widget's scale
	 *
	 * @param scaleX number
	 * @param scaleY number
	 */
	setScale(scaleX: number, scaleY: number): any;
	/**
	 * Set the widget's position, the object's origin is in the center
	 *
	 * @param left number
	 * @param top number
	 */
	setPosition(left: number, top: number): any;
	/**
	 * Get the widget's position
	 */
	getPosition(): {
		left: number;
		top: number;
	};
	/**
	 * Set the widget's position based on geographical coordinates, only for map boards (see [[IWidgetBoardApi.isMap]]})
	 *
	 * @param lon longitude
	 * @param lat latitude
	 */
	setPositionLonLat(lon: number, lat: number): any;
	/**
	 * Get the widget's position based on geographical coordinates, only for map boards (see [[IWidgetBoardApi.isMap]]})
	 */
	getPositionLonLat(): {
		lon: number;
		lat: number;
	};
	/**
	 * Get widget's data field value
	 *
	 * @param field fieldname
	 */
	getDataField(field: any): any;
	/**
	 * Set the objects data field(s) to given values, for arrays the contents will be concatenated so
	 * non-delta updates need to be used for removal/clearing
	 *
	 * ```typescript
	 * setDataField('fieldA', 'value');
	 *
	 * setDataField('users', ['userA','userB','userC'], false); // create or set array
	 * setDataField('users', ['userD']); // append
	 *
	 * setDataField('users', getDataField('users').filter(v => v === 'userB'), false); // remove 'userB'
	 * setDataField('users', null, false); // remove array
	 * ```
	 *
	 * @param field field name or key value object
	 * @param value value, in case field is name
	 * @param delta indicate whether the changed values should be merged or replaced, can be omitted - defaults to true
	 */
	setDataField(field: string | Record<string, any>, value: any, delta?: boolean): Promise<any>;
	/**
	 * Set the objects data field(s) to given values, for arrays the contents will be concatenated so
	 * non-delta updates need to be used for removal/clearing
	 *
	 * ```typescript
	 * setDataField({
	 *    fieldA: 'valueA',
	 *    fieldB: 5,
	 *    'users': ['userA','userB','userC'] // create array
	 * }); // add some fields as an object
	 *
	 * @param fields key-value object for fields
	 * @param delta
	 */
	setDataField(fields: Record<string, any>, delta?: boolean): Promise<any>;
	/**
	 * [[Observable]] that emits whenever the widget data is changed
	 */
	readonly dataChanged$: Observable<Record<string, any>>;
	/**
	 * Get an [[Observable]] that fires only when a specific field changes
	 *
	 * @param field fieldname
	 * @param startWithCurrent if set to true the observable will emit immediately with current value
	 */
	getFieldChanged$(field: string, startWithCurrent?: boolean): Observable<any>;
	/**
	 * Enable object resizing mode (click on resize handle to get to the resize mode)
	 */
	enableResizing: boolean;
	/**
	 * Enable double click to zoom into an object
	 */
	dblClickToZoom: boolean;
	/**
	 * Hide remote user cursors above the object
	 */
	hideRemoteCursors: boolean;
	/**
	 * Show confirm dialog before removing object
	 */
	shouldConfirmRemoval: boolean;
	/**
	 * An [[Observable]] that emits whenever the widget's interactibility should be updated.
	 * You as the developer need to decide whether the widget needs to be interactible or not,
	 * and specifically which part of the widget is interactible.
	 * This is so the object can be moved when first selecting etc.
	 *
	 * Most of the time it should suffice to set `pointer-events: none` on the root element of your widget
	 *
	 * ```typescript
	 * haptic.interactibility$.subscribe((v:Interactibility) => {
	 *    haptic.rootNode.style.pointerEvents = v.interactible ? '' : 'none';
	 * })
	 * ```
	 *
	 * The default value of [[Interactibility.interactible]] is computed for you and should fit most use cases.
	 */
	readonly interactibility$: Observable<Interactibility>;
	/**
	 * Contains last state from [[IWidgetApi.interactibility$]] observable.
	 */
	readonly interactibility: Interactibility;
	/**
	 * Indicates whether the object is selected by another client
	 */
	readonly locked: boolean;
	/**
	 * [[Observable]] that emits whenever [[locked]] changes
	 */
	readonly locked$: Observable<boolean>;
	/**
	 * Indicates whether the object is selected by on this client
	 */
	readonly selected: boolean;
	/**
	 * [[Observable]] that emits whenever [[selected]] changes
	 */
	readonly selected$: Observable<boolean>;
	/**
	 * Indicates whether the object is multi-selected with other objects
	 */
	readonly multiSelected: boolean;
	/**
	 * [[Observable]] that emits whenever [[multiSelected]] changes
	 */
	readonly multiSelected$: Observable<boolean>;
	/**
	 * Indicates whether the object is inside the viewport
	 */
	readonly inViewport: boolean;
	/**
	 * [[Observable]] that emits whenever [[inViewport]] changes
	 */
	readonly inViewport$: Observable<boolean>;
	/**
	 * This number combines the board canvas zoom level and this widget's scaling to
	 * give you the final scale transform, this is useful when fixing 3rd party
	 * libraries that assume the DOM element is not scaled via ```transform``` css.
	 */
	readonly finalScaleTransform: number;
	/**
	 * Indicates whether the object is currently being transformed (scaled/moved/rotated)
	 */
	readonly transforming: boolean;
	/**
	 * Emits when [[transforming]] changes
	 */
	readonly transforming$: Observable<boolean>;
	/**
	 * Trigger an action
	 *
	 * @param actionId one of the `action.id`s listed in [[actionTriggers]]
	 */
	triggerAction(actionId: string): void;
	/**
	 * Describe what actions this object can trigger (for use in the action system)
	 */
	actionTriggers: {
		label: string;
		id: string;
	}[];
	/**
	 * Describe custom buttons to be shown in the object context menu when selected.
	 * Note that this will update the UI whenever it is assigned a new value so make sure
	 * not to update in a `requestAnimationFrame` loop or similar since it will make the UI
	 * unresponsive (due to the constant updates).
	 */
	contextMenuButtons: ContextMenuButtonDefinition[];
	/**
	 * Describe form fields for custom object settings to be shown in the settings dialog
	 * (a 'Widget Settings' tab will be shown if present).
	 * Note that this will update the UI whenever it is assigned a new value so make sure
	 * not to update in a `requestAnimationFrame` loop or similar since it will make the UI
	 * unresponsive (due to the constant updates).
	 */
	objectSettings: FormlyFieldConfig[];
	/**
	 * Show an independent dialog with a custom Formly form for model type <T>.
	 *
	 * @param settings dialog description
	 * @template T model type
	 */
	showFormDialog<T extends FormlyDialogModel = FormlyDialogModel>(settings: FormlyDialogSettings<T>): Promise<T | false | "">;
	/**
	 * Logging service
	 */
	readonly logService: ILogger;
	/**
	 * Utilities
	 */
	readonly utils: typeof Utils;
	/**
	 * Send a message to this widgets's instances in other clients, the data is not stored anywhere
	 * so this should only be used when that's not needed.
	 *
	 * @param payload any JSON-serializable object
	 * @param userConnectionId if specified send the message only to that user
	 */
	sendMessage(payload: Record<string, unknown>, userConnectionId?: string): any;
	/**
	 * An [[Observable]] that emits the payload whenever a message from [[sendMessage]] is received
	 */
	readonly message$: Observable<WidgetMessageDto>;
	/**
	 * Send and store a sync message for all objects linked to this one,
	 * the objects don't have to be initialized in other clients like with [[sendMessage]]
	 * as this is persisted
	 *
	 * @param data any JSON-serializable payload
	 */
	sendSyncMessage(data: any): any;
	/**
	 * Get last sync message
	 */
	getLastSyncMessage(): any;
	/**
	 * [[Observable]] that emits whenever a sync message is received
	 */
	readonly syncMessage$: Observable<ObjectSyncMessageDto>;
	/**
	 * [[Observable]] that emits whenever an object is linked to this one (so it will now
	 * receive sync messages)
	 */
	readonly objectLinked$: Observable<ObjectLinkedNotificationData>;
	/**
	 * [[Observable]] that emits whenever an object is unlinked
	 */
	readonly objectUnlinked$: Observable<ObjectLinkedNotificationData>;
	/**
	 * [[Observable]] that emits whenever this object's links are changed
	 */
	readonly objectLinksChanged$: Observable<ObjectLinkedNotificationData>;
	/**
	 * Query the object's extra data. Extra data should be used for any data that's larger or
	 * essentially not needed unless some condition is met eg. user interaction.
	 *
	 * @param query
	 */
	queryExtraData(query: IExtraDataQuery): Promise<BoardObjectExtraDataQueryResultDto>;
	/**
	 * Create or update the extra data entry
	 *
	 * @param dataType
	 * @param data
	 * @param referenceId
	 */
	upsertExtraData(dataType: BoardObjectExtraDataType, data: any, referenceId?: string): Promise<any>;
	/**
	 * Create a new extra data entry
	 *
	 * @param dataType
	 * @param data
	 * @param referenceId
	 */
	createExtraData(dataType: BoardObjectExtraDataType, data: any, referenceId?: string): Promise<any>;
	/**
	 * Update existing extra data entry
	 *
	 * @param dataType
	 * @param data
	 * @param delta
	 * @param referenceId
	 */
	updateExtraData(dataType: BoardObjectExtraDataType, data: any, delta?: boolean, referenceId?: string): Promise<any>;
	/**
	 * Delete extra data entry or entries
	 *
	 * @param dataType
	 * @param deletionType
	 * @param referenceId
	 */
	deleteExtraData(dataType: BoardObjectExtraDataType, deletionType: ObjectExtraDataDeletionType, referenceId?: string): Promise<any>;
	/**
	 * [[Observable]] that emits whenever a new extra data entry is created for this object
	 */
	readonly extraDataCreated$: Observable<ObjectExtraDataCreatedDto>;
	/**
	 * [[Observable]] that emits whenever an extra data entry is modified
	 */
	readonly extraDataModified$: Observable<ObjectExtraDataModifiedDto>;
	/**
	 * [[Observable]] that emits whenever an extra data entry is removed
	 */
	readonly extraDataDeleted$: Observable<ObjectExtraDataDeletedDto>;
}
/**
 * Alleo API wrapper init function description
 */
export declare type WidgetInitFunction = (haptic: IWidgetApi, window: Window, document: Document) => Promise<void>;

export {}

declare global {
   const haptic: IWidgetApi
}
